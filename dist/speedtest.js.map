{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "client/speedtest.js",
    "client/event-dispatcher.js",
    "client/modules/bandwidth.js",
    "client/modules/http.js",
    "client/modules/latency.js",
    "client/timing.js",
    "client/utilities.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar LatencyModule = require('./modules/latency'),\n    BandwidthModule = require('./modules/bandwidth');\n\nvar SpeedTest = module.exports = function(options) {\n    // Initialize the modules\n    this._modules = {};\n    this._setModule('latency', new LatencyModule(options))\n        ._setModule('upload', new BandwidthModule('upload', options))\n        ._setModule('download', new BandwidthModule('download', options));\n};\n\nvar fn = SpeedTest.prototype;\n\nfn.module = function(name) {\n    return this._modules[name] || null;\n};\n\nfn.isRequesting = function() {\n    var modules = this._modules,\n        requesting = false;\n\n    for (var i in modules) {\n        if (modules.hasOwnProperty(i)) {\n            requesting = requesting || modules[i].isRequesting();\n        }\n    }\n\n    return requesting;\n};\n\nfn._setModule = function(name, object) {\n    var _this = this;\n\n    if (object) {\n        this._modules[name] = object.on('_newRequest', function() {\n            return !_this.isRequesting();\n        });\n    }\n\n    return this;\n};\n",
    "'use strict';\n\nvar EventDispatcher = module.exports = function() {\n    this._events = {}; // Contains all the event callbacks, organized by event types.\n};\n\nvar fn = EventDispatcher.prototype;\n\nfn.on = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If inexistant, create the array used to store the callbacks.\n    if (!events) {\n        events = this._events[eventType] = [];\n    }\n\n    // If the callback isn't already registered, store it.\n    if (!~events.indexOf(callback)) {\n        events.push(callback);\n    }\n\n    return this;\n};\n\nfn.off = function(eventType, callback) {\n    var events = this._events[eventType];\n\n    // If there is no specified callback, simply delete all the callbacks binded to the provided event type.\n    if (typeof callback == 'undefined' && events) {\n        delete this._events[eventType];\n    } else {\n        var eventIndex = events ? events.indexOf(callback) : -1;\n\n        // If the callback is registered, remove it from the array.\n        if (~eventIndex) {\n            events.splice(eventIndex, 1);\n        }\n    }\n\n    return this;\n};\n\nfn.trigger = function(eventType, extraParameters, context) {\n    var events = this._events[eventType] || [];\n    extraParameters = extraParameters || [];\n\n    // A callback can return a boolean value which will be logically compared to the other callbacks values before\n    // being returned by the trigger() method. This allows a callback to send a \"signal\" to the caller, like\n    // cancelling an action.\n    var returnValue = true;\n\n    events.forEach(function(callback) {\n        // A callback must explicitly return false if it wants the trigger() method to return false, undefined will\n        // not work. This avoids crappy callbacks to mess up with the triggering system.\n        var value = callback.apply(this, extraParameters);\n            value = value !== false ? true : false;\n\n        returnValue = returnValue && value; // Compare the result of the callback to the actual return value.\n    }, context);\n\n    return returnValue;\n};\n",
    "'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar BandwidthModule = module.exports = function(loadingType, options) {\n    var validLoadingTypes = ['upload', 'download'];\n    loadingType = (~validLoadingTypes.indexOf(loadingType)) ? loadingType : 'download';\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        dataSize: {\n            upload: 2 * 1024 * 1024, // 2 MB\n            download: 10 * 1024 * 1024, // 10 MB\n            multiplier: 2\n        }\n    }, options);\n\n    // Call parent constructor.\n    HttpModule.call(this, loadingType, options);\n\n    // Define the object properties.\n    this._loadingType = loadingType;\n\n    this._intendedEnd = false;\n    this._isRestarting = false;\n\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n    this._avgSpeed = null;\n\n    this._requestID = 0;\n    this._progressID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        progress: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initBandwidthConfig();\n};\n\nvar fn = BandwidthModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    var loadingType = this._loadingType,\n        dataSize = this._options.dataSize,\n        reqID = this._requestID++;\n\n    this._intendedEnd = false;\n    this._lastLoadedValue = null;\n    this._speedRecords = [];\n\n    // Trigger the start event.\n    if (!this._isRestarting) {\n        this.trigger('start', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n    }\n\n    // Create unique timing labels for the new request.\n    var labels = this._timingLabels;\n    labels.start = loadingType +'-'+ reqID + '-start';\n    labels.progress = loadingType +'-'+ reqID + '-progress';\n    labels.end = loadingType +'-'+ reqID + '-end';\n    labels.measure = loadingType +'-'+ reqID + '-measure';\n\n    // Generate some random data to upload to the server. Here we're using a Blob instead of an ArrayBuffer because\n    // of a bug in Chrome (tested in v33.0.1750.146), causing a freeze of the page while trying to directly upload\n    // an ArrayBuffer (through an ArrayBufferView). The freeze lasts nearly 4.5s for 10MB of data. Using a Blob\n    // seems to solve the problem.\n    var blob = (loadingType == 'upload') ? new Blob([new ArrayBuffer(dataSize.upload)]) : null;\n\n    var type = (loadingType == 'download') ? 'GET' : 'POST';\n\n    // Initiate and send a new request.\n    this._newRequest(type, {\n        size: dataSize.download\n    })._sendRequest(blob);\n};\n\nfn.abort = function() {\n    this._intendedEnd = true;\n    return this._abort();\n};\n\nfn._initBandwidthConfig = function() {\n    var _this = this,\n        loadingType = this._loadingType,\n        eventsPrefix = (loadingType == 'upload') ? 'xhr-upload-' : 'xhr-';\n\n    this.on(eventsPrefix +'loadstart', function() {\n        Timing.mark(_this._timingLabels.start);\n    });\n\n    this.on(eventsPrefix +'progress', function(event) {\n        _this._progress(event);\n    });\n\n    this.on(eventsPrefix +'timeout', function() {\n        _this._timeout();\n    });\n\n    this.on(eventsPrefix +'loadend', function() {\n        _this._end();\n    });\n};\n\nfn._progress = function(event) {\n    var labels = this._timingLabels,\n        progressID = this._progressID++,\n        markLabel = labels.progress +'-'+ progressID,\n        loaded = event.loaded;\n\n    Timing.mark(markLabel);\n\n    // Measure the average speed (B/s) since the request started.\n    var avgMeasure = Timing.measure(\n            labels.measure +'-avg-'+ progressID,\n            labels.start,\n            markLabel\n        ),\n        avgSpeed = loaded / avgMeasure * 1000;\n\n    var instantSpeed;\n\n    if (!this._lastLoadedValue) { // We are executing the first progress event of the current request.\n        instantSpeed = avgSpeed; // The instant speed of the first progress event is equal to the average one.\n    } else {\n        // Measure the instant speed (B/s). Which defines the speed between two progress events.\n        var instantMeasure = Timing.measure(\n            labels.measure +'-instant-'+ progressID,\n            // Set the mark of the previous progress event as the starting point.\n            labels.progress +'-'+ (progressID - 1),\n            markLabel\n        );\n        instantSpeed = (loaded - this._lastLoadedValue) / instantMeasure * 1000;\n    }\n\n    // Save the `loaded` property of the event for the next progress event.\n    this._lastLoadedValue = loaded;\n\n    // Save the measures.\n    this._avgSpeed = avgSpeed;\n    this._speedRecords.push(instantSpeed);\n\n    this.trigger('progress', [avgSpeed, instantSpeed]);\n};\n\nfn._timeout = function() {\n    this._intendedEnd = true;\n};\n\nfn._end = function() {\n    // A timeout or an abort occured, bypass the further requests and trigger the \"end\" event.\n    if (this._intendedEnd) {\n        this._isRestarting = false;\n        this.trigger('end', [this._avgSpeed, this._speedRecords]);\n    }\n\n    // The request ended to early, restart it with an increased data size.\n    else {\n        var loadingType = this._loadingType,\n            dataSize = this._options.dataSize;\n\n        dataSize.upload *= dataSize.multiplier;\n        dataSize.download *= dataSize.multiplier;\n\n        this.trigger('restart', [(loadingType == 'upload') ? dataSize.upload : dataSize.download]);\n\n        this._isRestarting = true;\n        this.start();\n    }\n};\n",
    "'use strict';\n\nvar EventDispatcher = require('../event-dispatcher'),\n    Utilities = require('../utilities');\n\nvar HttpModule = module.exports = function(moduleName, options) {\n    // Call parent constructor.\n    EventDispatcher.call(this);\n\n    // Define default options and override them by the ones provided at instanciation.\n    options = Utilities.extend({\n        endpoint: './speedtest.php',\n        delay: 8000\n    }, options);\n\n    // Define the object properties.\n    this._options = options;\n    this._moduleName = moduleName;\n    this._xhr = null;\n    this._lastURLToken = null;\n\n    this._requestingOverridden = false;\n    this._requesting = false;\n\n    // Initiate the object.\n    this._initHttpConfig();\n};\n\nvar fn = HttpModule.prototype = Object.create(EventDispatcher.prototype);\n\nfn.isRequesting = function() {\n    return this._requesting;\n};\n\nfn._initHttpConfig = function() {\n    var _this = this;\n\n    // Each time a request starts or ends, set the requesting value unless it has been overridden with the\n    // _setRequesting() method.\n    var loadstart = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = true;\n        }\n    };\n\n    this.on('xhr-loadstart', loadstart);\n    this.on('xhr-upload-loadstart', loadstart);\n\n    var loadend = function() {\n        if (!_this._requestingOverridden) {\n            _this._requesting = false;\n        }\n    };\n\n    this.on('xhr-loadend', loadend);\n    this.on('xhr-upload-loadend', loadend);\n};\n\nfn._newRequest = function(httpMethod, queryParams) {\n    // Check if a callback binded to the \"_newRequest\" event returns false, if it's the case, cancel the request\n    // creation. If the requesting status has been overridden, there's no need to cancel the request since the user\n    // should know what he's doing.\n    if (!this.trigger('_newRequest') && !this._requestingOverridden) {\n        console.warn('To ensure accurate measures, you can only make one request at a time.');\n        return this;\n    }\n\n    var _this = this,\n        options = this._options,\n        xhr = new XMLHttpRequest(),\n        validHttpMethods = ['GET', 'POST'];\n\n    // Prepare the new request.\n    if (!~validHttpMethods.indexOf(httpMethod)) {\n        console.warn('The HTTP method must be GET or POST.');\n        return this;\n    }\n\n    queryParams = queryParams || {};\n\n    // Generate an URL token to avoid any caching issues. This token will also allow to identify the request in the\n    // Resource Timing entries.\n    this._lastURLToken = 'speedtest-'+ (new Date).getTime();\n\n    // Append the query parameters.\n    var url = options.endpoint;\n        url += (~url.indexOf('?') ? '&' : '?') + 'module=' + this._moduleName;\n\n    Object.keys(queryParams).forEach(function(param) {\n        url += '&' + param + '=' + encodeURIComponent(queryParams[param]);\n    });\n\n    url += '&' + this._lastURLToken;\n\n    xhr.open(httpMethod, url);\n\n    // Define the timeout of the request.\n    xhr.timeout = options.delay;\n\n    // Abort the previous request if it hasn't been sent.\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.abort();\n    }\n\n    // Replace the old request by the new one.\n    this._xhr = xhr;\n\n    // Bind all the XHR events.\n    var eventTypes = ['loadstart', 'progress', 'abort', 'error', 'load', 'timeout', 'loadend', 'readystatechange'];\n\n    eventTypes.forEach(function(eventType) {\n        xhr.addEventListener(eventType, function() {\n            // A last progress event can be triggered once a request has timed out, ignore it.\n            if (eventType == 'progress' && !_this._requesting) {\n                return;\n            }\n\n            _this.trigger('xhr-'+ eventType, arguments, xhr);\n        });\n\n        // The XMLHttpRequestUpload interface supports all the above event types except the \"readystatechange\" one.\n        if (eventType != 'readystatechange') {\n            xhr.upload.addEventListener(eventType, function() {\n                _this.trigger('xhr-upload-'+ eventType, arguments, xhr);\n            });\n        }\n    });\n\n    return this;\n};\n\nfn._sendRequest = function(data) {\n    if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n        this._xhr.send(typeof data != 'undefined' ? data : null);\n    } else {\n        console.warn('A request must have been created before it can be sent.');\n    }\n\n    return this;\n};\n\nfn._abort = function() {\n    if (this._xhr) {\n        this._xhr.abort();\n    }\n\n    return this;\n};\n\nfn._getTimingEntry = function(callback) {\n    // The Resource Timing entries aren't immediately available once the 'load' event is triggered by an\n    // XMLHttpRequest, we must wait for another process tick to check for a refreshed list.\n    setTimeout((function(lastURLToken) {\n        return function() {\n            // Filter the timing entries to return only the one concerned by the last request made.\n            var entries = performance.getEntriesByType('resource').filter(function(entry) {\n                return ~entry.name.indexOf(lastURLToken);\n            });\n\n            // Return the entry through the callback.\n            typeof callback == 'function' && callback(entries.length ? entries[0] : null);\n        };\n    })(this._lastURLToken), 0);\n\n    return this;\n};\n\nfn._setRequesting = function(value) {\n    this._requestingOverridden = true;\n    this._requesting = value;\n};\n",
    "'use strict';\n\nvar HttpModule = require('./http'),\n    Timing = require('../timing'),\n    Utilities = require('../utilities');\n\nvar LatencyModule = module.exports = function(options) {\n    // We dont want any timeout during a latency calculation. Here we are using extend() because we want to edit the\n    // delay on a clone of the object and not the original one.\n    options = Utilities.extend(options, {\n        delay: 0\n    });\n\n    // Call parent constructor.\n    HttpModule.call(this, 'latency', options);\n\n    // Define the object properties.\n    this._requestsLeft = 0;\n    this._latencies = [];\n    this._requestID = 0;\n\n    // Unique labels for each request, exclusively used to make measures.\n    this._timingLabels = {\n        start: null,\n        end: null,\n        measure: null\n    };\n\n    // Initiate the object.\n    this._initLatencyConfig();\n};\n\nvar fn = LatencyModule.prototype = Object.create(HttpModule.prototype);\n\nfn.start = function() {\n    // Set the number of requests required to establish the network latency. If the browser doesn't support the\n    // Resource Timing API, add a request that will be ignored to avoid a longer request due to a possible\n    // DNS/whatever fetch.\n    this._requestsLeft = 5;\n    Timing.supportsResourceTiming() || this._requestsLeft++;\n\n    // Override the requesting value since a complete latency request consists off multiple ones.\n    this._setRequesting(true);\n\n    this._latencies = [];\n    this._nextRequest();\n\n    return this;\n};\n\nfn._initLatencyConfig = function() {\n    var _this = this;\n\n    // Calculate the latency with the Resource Timing API once the request is finished.\n    if (Timing.supportsResourceTiming()) {\n        this.on('xhr-load', function() {\n            _this._getTimingEntry(function(entry) {\n                // The latency calculation differs between an HTTP and an HTTPS connection.\n                // See: http://www.w3.org/TR/resource-timing/#processing-model\n                var latency = !entry.secureConnectionStart\n                                ? entry.connectEnd - entry.connectStart\n                                : entry.secureConnectionStart - entry.connectStart;\n\n                _this._latencies.push(latency);\n            });\n        });\n    }\n\n    // If the browser doesn't support the Resource Timing API, we fallback on a Datetime solution.\n    else {\n        var labels = this._timingLabels;\n\n        // Set a mark when the request starts.\n        this.on('xhr-loadstart', function() {\n            Timing.mark(labels.start);\n        });\n\n        this.on('xhr-readystatechange', function() {\n            // Ignore the first request (see the comments in the start() method) and calculate the latency if the\n            // headers have been received.\n            if (_this._requestsLeft < 5 && this.readyState == XMLHttpRequest.HEADERS_RECEIVED) {\n                // Save the timing measure.\n                Timing.mark(labels.end);\n                _this._latencies.push(Timing.measure(labels.measure, labels.start, labels.end));\n            }\n        });\n    }\n\n    this.on('xhr-load', function() {\n        // An anonymous callback is required to avoid the `this` key to be defined as the XHR object.\n        _this._nextRequest();\n    });\n};\n\nfn._nextRequest = function() {\n    if (this._requestsLeft--) {\n        var reqID = this._requestID++;\n\n        // Create unique timing labels for the new request.\n        var labels = this._timingLabels;\n        labels.start = 'latency-'+ reqID + '-start';\n        labels.end = 'latency-'+ reqID + '-end';\n        labels.measure = 'latency-'+ reqID + '-measure';\n\n        // Create the new request and send it.\n        this._newRequest('GET')._sendRequest();\n    } else {\n        var _this = this;\n\n        // All the requests are finished, set the requesting status to false.\n        this._setRequesting(false);\n\n        // If all the requests have been executed, calculate the average latency. Since the _getTimingEntry() method\n        // is asynchronous, wait for the next process tick to execute the _calculate() method, to be sure that all\n        // the latencies have been retrieved.\n        setTimeout(function() {\n            _this._calculate();\n        }, 0);\n    }\n};\n\nfn._calculate = function() {\n    var latencies = this._latencies,\n        isThereAnyZeroLatency = false;\n\n    // Get the average latency.\n    var avgLatency = latencies.reduce(function(a, b) {\n        // Check if there is any latency equal to zero.\n        isThereAnyZeroLatency = isThereAnyZeroLatency || (a == 0 || b == 0);\n        // Sum the current latency to the previous value.\n        return a + b;\n    }) / latencies.length;\n\n    // If there is any zero latency, display a warning.\n    isThereAnyZeroLatency && console.warn([\n        'At least one latency returned a zero value, this can be due to the configuration of your web server which',\n        'is probably using persistant connections. Check the documentation to solve this problem.'\n    ].join(' '));\n\n    // Trigger the \"end\" event with the average latency and the latency list as parameters.\n    this.trigger('end', [avgLatency, latencies]);\n};\n",
    "'use strict';\n\nvar Timing = module.exports = function() {};\n\nvar staticScope = Timing;\n\nstaticScope._marks = {};\nstaticScope._measures = {};\n\n// Does the browser support the following APIs?\nstaticScope._support = {\n    performance: !!window.performance,\n    userTiming: window.performance && performance.mark,\n    resourceTiming: window.performance && (typeof(performance.getEntriesByType) == \"function\") && performance.timing\n};\n\nstaticScope.mark = function(label) {\n    var support = this._support,\n        marks = this._marks;\n\n    if (support.userTiming) {\n        performance.mark(label);\n    } else if (support.performance) {\n        marks[label] = performance.now();\n    } else {\n        marks[label] = (new Date).getTime();\n    }\n\n    return this;\n};\n\nstaticScope.measure = function(measureLabel, markLabelA, markLabelB) {\n    var support = this._support,\n        marks = this._marks,\n        measures = this._measures;\n\n    if (typeof measures[measureLabel] == 'undefined') {\n        if (support.userTiming) {\n            performance.measure(measureLabel, markLabelA, markLabelB);\n            measures[measureLabel] = performance.getEntriesByName(measureLabel)[0].duration;\n        } else {\n            measures[measureLabel] = marks[markLabelB] - marks[markLabelA];\n        }\n    }\n\n    return measures[measureLabel];\n};\n\nstaticScope.supportsResourceTiming = function() {\n    return this._support.resourceTiming;\n};\n",
    "'use strict';\n\nfunction extend(destination, source) {\n    // Deep clone the objects to avoid any module to modify options of another module.\n    // See: http://stackoverflow.com/a/5344074/1513045\n    destination = JSON.parse(JSON.stringify(destination || {}));\n    source = JSON.parse(JSON.stringify(source || {}));\n\n    // Apply source values on the destination object.\n    Object.keys(source).forEach(function(key) {\n        destination[key] = source[key];\n    });\n\n    return destination;\n}\n\nexports.extend = extend;\n"
  ]
}