{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","speedtest.js","../lib/SpeedTest.js","../lib/EventDispatcher.js","../lib/Http/BandwidthModule.js","../lib/Http/HttpModule.js","../lib/Http/LatencyModule.js","../lib/Timing.js","../utils/helpers.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","SpeedTest","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"_interopRequire","obj","__esModule","_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","EventDispatcher","HttpModule","LatencyModule","BandwidthModule","Timing","assign","options","undefined","arguments","_modules","_setModule","isRequesting","modules","requesting","hasOwnProperty","name","object","_this","on","_exposeInternalClasses","../utils/helpers","./EventDispatcher","./Http/BandwidthModule","./Http/HttpModule","./Http/LatencyModule","./Timing",2,"_events","eventTypes","callback","Array","isArray","forEach","eventType","events","indexOf","push","off","eventIndex","splice","trigger","_len","extraParameters","_key","returnValue","apply",3,"_get","get","property","receiver","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_inherits","subClass","superClass","create","constructor","enumerable","__proto__","_utilsHelpers","defer","_HttpModule","loadingType","dataSize","upload","download","multiplier","_loadingType","_intendedEnd","_isRestarting","_lastLoadedValue","_speedRecords","_avgSpeed","_requestID","_progressID","_started","_firstProgress","_deferredProgress","_timingLabels","start","progress","end","measure","mark","xhr","readyState","XMLHttpRequest","LOADING","eventsPrefix","event","_progress","_timeout","_end","_options","reqID","labels","blob","Blob","ArrayBuffer","type","_newRequest","size","_sendRequest","abort","_abort","run","progressID","markLabel","loaded","instantSpeed","avgMeasure","avgSpeed","instantMeasure","../../utils/helpers","../Timing","./HttpModule",4,"_slice","slice","_EventDispatcher","moduleName","endpoint","delay","_moduleName","_xhr","_lastURLToken","_requestingOverridden","_requesting","httpMethod","queryParams","console","warn","validHttpMethods","tokenSuffix","Date","getTime","url","keys","param","encodeURIComponent","open","timeout","OPENED","addEventListener","concat","data","send","_getTimingEntry","setTimeout","lastURLToken","entries","performance","getEntriesByType","filter","entry","_setRequesting","../EventDispatcher",5,"latency","measures","attempts","_requestsLeft","_attemptsLeft","_latencies","supportsResourceTiming","_measure","_options$latency","_nextRequest","retry","requestsLeft","HEADERS_RECEIVED","secureConnectionStart","connectStart","connectEnd","latencies","avgLatency","reduce","b","join",6,"_marks","_measures","_support","userTiming","resourceTiming","timing","label","support","marks","now","measureLabel","markLabelA","markLabelB","getEntriesByName","duration",7,"isObject","valueOf","sources","source","cb","_class","defineProperty"],"mappings":"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","file":"speedtest.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.SpeedTest = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventDispatcher = _interopRequire(require(\"./EventDispatcher\"));\n\nvar HttpModule = _interopRequire(require(\"./Http/HttpModule\"));\n\nvar LatencyModule = _interopRequire(require(\"./Http/LatencyModule\"));\n\nvar BandwidthModule = _interopRequire(require(\"./Http/BandwidthModule\"));\n\nvar Timing = _interopRequire(require(\"./Timing\"));\n\nvar assign = require(\"../utils/helpers\").assign;\n\nvar SpeedTest = (function () {\n    function SpeedTest() {\n        var options = arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, SpeedTest);\n\n        // Initialize the modules\n        this._modules = {};\n        this._setModule(\"latency\", new LatencyModule(options))._setModule(\"upload\", new BandwidthModule(\"upload\", options))._setModule(\"download\", new BandwidthModule(\"download\", options));\n    }\n\n    _createClass(SpeedTest, {\n        isRequesting: {\n            value: function isRequesting() {\n                var modules = this._modules,\n                    requesting = false;\n\n                for (var i in modules) {\n                    if (modules.hasOwnProperty(i)) {\n                        requesting = requesting || modules[i].isRequesting();\n                    }\n                }\n\n                return requesting;\n            }\n        },\n        _setModule: {\n            value: function _setModule(name, object) {\n                var _this = this;\n\n                if (object) {\n                    this[name] = this._modules[name] = object.on(\"_newRequest\", function () {\n                        return !_this.isRequesting();\n                    });\n                }\n\n                return this;\n            }\n        }\n    }, {\n        _exposeInternalClasses: {\n\n            /**\n             * Only for testing purposes! Exposes all the internal classes to the global scope.\n             */\n\n            value: function _exposeInternalClasses() {\n                assign(window, { EventDispatcher: EventDispatcher, HttpModule: HttpModule, LatencyModule: LatencyModule, BandwidthModule: BandwidthModule, Timing: Timing });\n            }\n        }\n    });\n\n    return SpeedTest;\n})();\n\nmodule.exports = SpeedTest;\n\n},{\"../utils/helpers\":7,\"./EventDispatcher\":2,\"./Http/BandwidthModule\":3,\"./Http/HttpModule\":4,\"./Http/LatencyModule\":5,\"./Timing\":6}],2:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventDispatcher = (function () {\n    function EventDispatcher() {\n        _classCallCheck(this, EventDispatcher);\n\n        // Contains all the event callbacks, organized by event types.\n        this._events = {};\n    }\n\n    _createClass(EventDispatcher, {\n        on: {\n            value: function on(eventTypes, callback) {\n                var _this = this;\n\n                eventTypes = Array.isArray(eventTypes) ? eventTypes : [eventTypes];\n\n                eventTypes.forEach(function (eventType) {\n                    var events = _this._events[eventType] = _this._events[eventType] || [];\n\n                    // If the callback isn't already registered, store it.\n                    if (! ~events.indexOf(callback)) {\n                        events.push(callback);\n                    }\n                });\n\n                return this;\n            }\n        },\n        off: {\n            value: function off(eventTypes, callback) {\n                var _this = this;\n\n                eventTypes = Array.isArray(eventTypes) ? eventTypes : [eventTypes];\n\n                eventTypes.forEach(function (eventType) {\n                    var events = _this._events[eventType];\n\n                    // If there is no specified callback, simply delete all the callbacks binded to the provided event type.\n                    if (callback == undefined && events) {\n                        delete _this._events[eventType];\n                    } else {\n                        var eventIndex = events ? events.indexOf(callback) : -1;\n\n                        // If the callback is registered, remove it from the array.\n                        if (~eventIndex) {\n                            events.splice(eventIndex, 1);\n                        }\n                    }\n                });\n\n                return this;\n            }\n        },\n        trigger: {\n            value: function trigger(eventType) {\n                for (var _len = arguments.length, extraParameters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    extraParameters[_key - 1] = arguments[_key];\n                }\n\n                var events = this._events[eventType] || [];\n\n                // A callback can return a boolean value which will be logically compared to the other callbacks values before\n                // being returned by the trigger() method. This allows a callback to send a \"signal\" to the caller, like\n                // cancelling an action.\n                var returnValue = true;\n\n                events.forEach(function (callback) {\n                    // A callback must explicitly return false if it wants the trigger() method to return false, undefined will\n                    // not work. This avoids crappy callbacks to mess up with the triggering system.\n                    var value = callback.apply(undefined, extraParameters);\n                    value = value !== false ? true : false;\n\n                    returnValue = returnValue && value; // Compare the result of the callback to the actual return value\n                });\n\n                return returnValue;\n            }\n        }\n    });\n\n    return EventDispatcher;\n})();\n\nmodule.exports = EventDispatcher;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar HttpModule = _interopRequire(require(\"./HttpModule\"));\n\nvar Timing = _interopRequire(require(\"../Timing\"));\n\nvar _utilsHelpers = require(\"../../utils/helpers\");\n\nvar assign = _utilsHelpers.assign;\nvar defer = _utilsHelpers.defer;\n\nvar BandwidthModule = (function (_HttpModule) {\n    function BandwidthModule(loadingType) {\n        var _this = this;\n\n        var options = arguments[1] === undefined ? {} : arguments[1];\n\n        _classCallCheck(this, BandwidthModule);\n\n        // Instanciate the parent\n        loadingType = ~[\"upload\", \"download\"].indexOf(loadingType) ? loadingType : \"download\";\n\n        options = assign({\n            dataSize: {\n                upload: 2 * 1024 * 1024, // 2 MB\n                download: 10 * 1024 * 1024, // 10 MB\n                multiplier: 2\n            }\n        }, options);\n\n        _get(Object.getPrototypeOf(BandwidthModule.prototype), \"constructor\", this).call(this, loadingType, options);\n\n        // Define the object properties\n        this._loadingType = loadingType;\n\n        this._intendedEnd = false;\n        this._isRestarting = false;\n\n        this._lastLoadedValue = null;\n        this._speedRecords = [];\n        this._avgSpeed = null;\n\n        this._requestID = 0;\n        this._progressID = 0;\n\n        this._started = false;\n        this._firstProgress = true;\n        this._deferredProgress;\n\n        // Unique labels for each request, exclusively used to make measures.\n        this._timingLabels = {\n            start: null,\n            progress: null,\n            end: null,\n            measure: null\n        };\n\n        // Bind to XHR events\n        this.on(\"xhr-upload-loadstart\", function () {\n            return Timing.mark(_this._timingLabels.start);\n        });\n        this.on(\"xhr-readystatechange\", function (xhr) {\n            if (!_this._started && xhr.readyState == XMLHttpRequest.LOADING) {\n                Timing.mark(_this._timingLabels.start);\n                _this._started = true;\n            }\n        });\n\n        var eventsPrefix = loadingType == \"upload\" ? \"xhr-upload\" : \"xhr\";\n\n        this.on(\"\" + eventsPrefix + \"-progress\", function (xhr, event) {\n            return _this._progress(event);\n        });\n        this.on(\"\" + eventsPrefix + \"-timeout\", function () {\n            return _this._timeout();\n        });\n        this.on(\"\" + eventsPrefix + \"-loadend\", function () {\n            return _this._end();\n        });\n    }\n\n    _inherits(BandwidthModule, _HttpModule);\n\n    _createClass(BandwidthModule, {\n        start: {\n            value: function start() {\n                var loadingType = this._loadingType,\n                    dataSize = this._options.dataSize,\n                    reqID = this._requestID++;\n\n                this._intendedEnd = false;\n                this._lastLoadedValue = null;\n                this._speedRecords = [];\n                this._started = false;\n                this._firstProgress = true;\n                this._deferredProgress = defer();\n\n                // Trigger the start event\n                if (!this._isRestarting) {\n                    this.trigger(\"start\", loadingType == \"upload\" ? dataSize.upload : dataSize.download);\n                }\n\n                // Create unique timing labels for the new request\n                var labels = this._timingLabels;\n                labels.start = \"\" + loadingType + \"-\" + reqID + \"-start\";\n                labels.progress = \"\" + loadingType + \"-\" + reqID + \"-progress\";\n                labels.end = \"\" + loadingType + \"-\" + reqID + \"-end\";\n                labels.measure = \"\" + loadingType + \"-\" + reqID + \"-measure\";\n\n                // Generate some random data to upload to the server. Here we're using a Blob instead of an ArrayBuffer because\n                // of a bug in Chrome (tested in v33.0.1750.146), causing a freeze of the page while trying to directly upload\n                // an ArrayBuffer (through an ArrayBufferView). The freeze lasts nearly 4.5s for 10MB of data. Using a Blob\n                // seems to solve the problem.\n                var blob = loadingType == \"upload\" ? new Blob([new ArrayBuffer(dataSize.upload)]) : null;\n\n                var type = loadingType == \"download\" ? \"GET\" : \"POST\";\n\n                // Initiate and send a new request\n                this._newRequest(type, {\n                    size: dataSize.download\n                })._sendRequest(blob);\n            }\n        },\n        abort: {\n            value: function abort() {\n                this._intendedEnd = true;\n                return this._abort();\n            }\n        },\n        _progress: {\n            value: function _progress(event) {\n                var _this = this;\n\n                // Ignore the first progress event, it generally contributes to get incoherent values.\n                if (this._firstProgress) {\n                    return this._firstProgress = false;\n                } // Execute the previous progress trigger\n                this._deferredProgress.run();\n\n                var labels = this._timingLabels,\n                    progressID = this._progressID++,\n                    markLabel = \"\" + labels.progress + \"-\" + progressID,\n                    loaded = event.loaded;\n\n                Timing.mark(markLabel);\n\n                // Measure the average speed (B/s) since the request started\n                var avgMeasure = Timing.measure(\"\" + labels.measure + \"-avg-\" + progressID, labels.start, markLabel),\n                    avgSpeed = loaded / avgMeasure * 1000;\n\n                var instantSpeed;\n\n                if (!this._lastLoadedValue) {\n                    // We are executing the first progress event of the current request\n                    instantSpeed = avgSpeed; // The instant speed of the first progress event is equal to the average one\n                } else {\n                    // Measure the instant speed (B/s), which defines the speed between two progress events.\n                    var instantMeasure = Timing.measure(\"\" + labels.measure + \"-instant-\" + progressID,\n                    // Set the mark of the previous progress event as the starting point\n                    \"\" + labels.progress + \"-\" + (progressID - 1), markLabel);\n                    instantSpeed = (loaded - this._lastLoadedValue) / instantMeasure * 1000;\n                }\n\n                // Save the `loaded` property of the event for the next progress event\n                this._lastLoadedValue = loaded;\n\n                // Defer measures saving and event triggering, this allows to cancel the last progress event, which can generate\n                // incoherent values.\n                this._deferredProgress = defer(function () {\n                    _this._avgSpeed = avgSpeed;\n                    _this._speedRecords.push(instantSpeed);\n\n                    _this.trigger(\"progress\", avgSpeed, instantSpeed);\n                });\n            }\n        },\n        _timeout: {\n            value: function _timeout() {\n                this._intendedEnd = true;\n            }\n        },\n        _end: {\n            value: function _end() {\n                // A timeout or an abort occured, bypass the further requests and trigger the \"end\" event.\n                if (this._intendedEnd) {\n                    this._isRestarting = false;\n                    this.trigger(\"end\", this._avgSpeed, this._speedRecords);\n                }\n\n                // The request ended to early, restart it with an increased data size.\n                else {\n                    var loadingType = this._loadingType,\n                        dataSize = this._options.dataSize;\n\n                    dataSize.upload *= dataSize.multiplier;\n                    dataSize.download *= dataSize.multiplier;\n\n                    this.trigger(\"restart\", loadingType == \"upload\" ? dataSize.upload : dataSize.download);\n\n                    this._isRestarting = true;\n                    this.start();\n                }\n            }\n        }\n    });\n\n    return BandwidthModule;\n})(HttpModule);\n\nmodule.exports = BandwidthModule;\n\n},{\"../../utils/helpers\":7,\"../Timing\":6,\"./HttpModule\":4}],4:[function(require,module,exports){\n\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _slice = Array.prototype.slice;\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventDispatcher = _interopRequire(require(\"../EventDispatcher\"));\n\nvar assign = require(\"../../utils/helpers\").assign;\n\nvar HttpModule = (function (_EventDispatcher) {\n    function HttpModule(moduleName) {\n        var _this = this;\n\n        var options = arguments[1] === undefined ? {} : arguments[1];\n\n        _classCallCheck(this, HttpModule);\n\n        _get(Object.getPrototypeOf(HttpModule.prototype), \"constructor\", this).call(this);\n\n        options = assign({\n            endpoint: \"./speedtest.php\",\n            delay: 8000\n        }, options);\n\n        // Define the object properties\n        this._options = options;\n        this._moduleName = moduleName;\n        this._xhr = null;\n        this._lastURLToken = null;\n\n        this._requestingOverridden = false;\n        this._requesting = false;\n\n        // Each time a request starts or ends, set the requesting value unless it has been overridden with the\n        // _setRequesting() method.\n        this.on([\"xhr-loadstart\", \"xhr-upload-loadstart\"], function () {\n            if (!_this._requestingOverridden) {\n                _this._requesting = true;\n            }\n        });\n\n        this.on([\"xhr-loadend\", \"xhr-upload-loadend\"], function () {\n            if (!_this._requestingOverridden) {\n                _this._requesting = false;\n            }\n        });\n    }\n\n    _inherits(HttpModule, _EventDispatcher);\n\n    _createClass(HttpModule, {\n        isRequesting: {\n            value: function isRequesting() {\n                return this._requesting;\n            }\n        },\n        _newRequest: {\n            value: function _newRequest(httpMethod, queryParams) {\n                // Check if a callback binded to the \"_newRequest\" event returns false, if it's the case, cancel the request\n                // creation. If the requesting status has been overridden, there's no need to cancel the request since the user\n                // should know what he's doing.\n                if (!this.trigger(\"_newRequest\") && !this._requestingOverridden) {\n                    console.warn(\"To ensure accurate measures, you can only make one request at a time.\");\n                    return this;\n                }\n\n                var options = this._options,\n                    xhr = new XMLHttpRequest(),\n                    validHttpMethods = [\"GET\", \"POST\"];\n\n                // Prepare the new request.\n                if (! ~validHttpMethods.indexOf(httpMethod)) {\n                    console.warn(\"The HTTP method must be GET or POST.\");\n                    return this;\n                }\n\n                queryParams = queryParams || {};\n\n                // Generate an URL token to avoid any caching issues. This token will also allow to identify the request in the\n                // Resource Timing entries.\n                var tokenSuffix = new Date().getTime();\n                this._lastURLToken = \"speedtest-\" + tokenSuffix;\n\n                // Append the query parameters\n                var url = options.endpoint;\n                url += ~url.indexOf(\"?\") ? \"&\" : \"?\";\n                url += \"module=\" + this._moduleName;\n\n                Object.keys(queryParams).forEach(function (param) {\n                    var value = encodeURIComponent(queryParams[param]);\n                    url += \"&\" + param + \"=\" + value;\n                });\n\n                url += \"&\" + this._lastURLToken;\n\n                xhr.open(httpMethod, url);\n\n                // Define the timeout of the request\n                xhr.timeout = options.delay;\n\n                // Abort the previous request if it hasn't been sent\n                if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n                    this._xhr.abort();\n                }\n\n                // Replace the old request by the new one\n                this._xhr = xhr;\n\n                // Bind all the XHR events\n                var self = this,\n                    eventTypes = [\"loadstart\", \"progress\", \"abort\", \"error\", \"load\", \"timeout\", \"loadend\", \"readystatechange\"];\n\n                eventTypes.forEach(function (eventType) {\n                    xhr.addEventListener(eventType, function () {\n                        // A last progress event can be triggered once a request has timed out, ignore it.\n                        if (eventType == \"progress\" && !self._requesting) {\n                            return;\n                        }\n\n                        self.trigger.apply(self, [\"xhr-\" + eventType, xhr].concat(_slice.call(arguments)));\n                    });\n\n                    // The XMLHttpRequestUpload interface supports all the above event types except the \"readystatechange\" one\n                    if (eventType != \"readystatechange\") {\n                        xhr.upload.addEventListener(eventType, function () {\n                            self.trigger.apply(self, [\"xhr-upload-\" + eventType, xhr].concat(_slice.call(arguments)));\n                        });\n                    }\n                });\n\n                return this;\n            }\n        },\n        _sendRequest: {\n            value: function _sendRequest(data) {\n                if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n                    this._xhr.send(typeof data != \"undefined\" ? data : null);\n                } else {\n                    console.warn(\"A request must have been created before it can be sent.\");\n                }\n\n                return this;\n            }\n        },\n        _abort: {\n            value: function _abort() {\n                if (this._xhr) {\n                    this._xhr.abort();\n                }\n\n                return this;\n            }\n        },\n        _getTimingEntry: {\n            value: function _getTimingEntry(callback) {\n                // The Resource Timing entries aren't immediately available once the 'load' event is triggered by an\n                // XMLHttpRequest, we must wait for another process tick to check for a refreshed list.\n                setTimeout((function (lastURLToken) {\n                    return function () {\n                        // Filter the timing entries to return only the one concerned by the last request made\n                        var entries = performance.getEntriesByType(\"resource\").filter(function (entry) {\n                            return ~entry.name.indexOf(lastURLToken);\n                        });\n\n                        // Return the entry through the callback\n                        typeof callback == \"function\" && callback(entries.length ? entries[0] : null);\n                    };\n                })(this._lastURLToken), 0);\n\n                return this;\n            }\n        },\n        _setRequesting: {\n            value: function _setRequesting(value) {\n                this._requestingOverridden = true;\n                this._requesting = value;\n            }\n        }\n    });\n\n    return HttpModule;\n})(EventDispatcher);\n\nmodule.exports = HttpModule;\n\n},{\"../../utils/helpers\":7,\"../EventDispatcher\":2}],5:[function(require,module,exports){\n\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inherits = function (subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar HttpModule = _interopRequire(require(\"./HttpModule\"));\n\nvar Timing = _interopRequire(require(\"../Timing\"));\n\nvar assign = require(\"../../utils/helpers\").assign;\n\nvar LatencyModule = (function (_HttpModule) {\n    function LatencyModule() {\n        var _this = this;\n\n        var options = arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, LatencyModule);\n\n        options = assign({\n            latency: {\n                measures: 5,\n                attempts: 3\n            }\n        }, options, {\n            delay: 0 // We dont want any timeout during a latency calculation\n        });\n\n        _get(Object.getPrototypeOf(LatencyModule.prototype), \"constructor\", this).call(this, \"latency\", options);\n\n        // Define the object properties\n        this._requestsLeft = 0;\n        this._attemptsLeft = 0;\n\n        this._latencies = [];\n        this._requestID = 0;\n\n        // Unique labels for each request, exclusively used to make measures.\n        this._timingLabels = {\n            start: null,\n            end: null,\n            measure: null\n        };\n\n        // Measure the latency with the Resource Timing API once the request is finished\n        if (Timing.supportsResourceTiming()) {\n            this.on(\"xhr-load\", function () {\n                return _this._measure();\n            });\n        }\n\n        // If the browser doesn't support the Resource Timing API, we fallback on a Datetime solution.\n        else {\n            // Set a mark when the request starts\n            this.on(\"xhr-loadstart\", function () {\n                return Timing.mark(_this._timingLabels.start);\n            });\n\n            // Then make a measure with the previous mark\n            this.on(\"xhr-readystatechange\", function (xhr) {\n                return _this._measure(xhr);\n            });\n        }\n    }\n\n    _inherits(LatencyModule, _HttpModule);\n\n    _createClass(LatencyModule, {\n        start: {\n            value: function start() {\n                // Set the number of requests required to establish the network latency. If the browser doesn't support the\n                // Resource Timing API, add a request that will be ignored to avoid a longer request due to a possible\n                // DNS/whatever fetch.\n                var _options$latency = this._options.latency;\n                var measures = _options$latency.measures;\n                var attempts = _options$latency.attempts;\n\n                this._requestsLeft = measures;\n                this._attemptsLeft = attempts * measures;\n\n                if (!Timing.supportsResourceTiming()) {\n                    this._requestsLeft++;\n                    this._attemptsLeft++;\n                }\n\n                // Override the requesting value since a complete latency request consists off multiple ones\n                this._setRequesting(true);\n\n                this._latencies = [];\n                this._nextRequest();\n\n                return this;\n            }\n        },\n        _nextRequest: {\n            value: function _nextRequest() {\n                var _this = this;\n\n                var retry = arguments[0] === undefined ? false : arguments[0];\n\n                var reqID = this._requestID++;\n                var requestsLeft = retry ? this._requestsLeft : this._requestsLeft--;\n\n                if (this._attemptsLeft-- && (requestsLeft || retry)) {\n                    // Create unique timing labels for the new request\n                    var labels = this._timingLabels;\n                    labels.start = \"latency-\" + reqID + \"-start\";\n                    labels.end = \"latency-\" + reqID + \"-end\";\n                    labels.measure = \"latency-\" + reqID + \"-measure\";\n\n                    // Create the new request and send it\n                    this._newRequest(\"GET\")._sendRequest();\n                } else {\n                    // All the requests are finished, set the requesting status to false.\n                    this._setRequesting(false);\n\n                    // If all the requests have been executed, calculate the average latency. Since the _getTimingEntry() method\n                    // is asynchronous, wait for the next process tick to execute the _end() method, to be sure that all the\n                    // latencies have been retrieved.\n                    setTimeout(function () {\n                        return _this._end();\n                    }, 0);\n                }\n            }\n        },\n        _measure: {\n            value: function _measure() {\n                var _this = this;\n\n                var xhr = arguments[0] === undefined ? null : arguments[0];\n\n                // With Resource Timing API\n                if (!xhr) {\n                    this._getTimingEntry(function (entry) {\n                        // The latency calculation differs between an HTTP and an HTTPS connection\n                        // See: http://www.w3.org/TR/resource-timing/#processing-model\n                        var latency = !entry.secureConnectionStart ? entry.connectEnd - entry.connectStart : entry.secureConnectionStart - entry.connectStart;\n\n                        if (latency) _this._latencies.push(latency);\n                        _this._nextRequest(!latency);\n                    });\n                }\n\n                // Without Resource Timing API\n                else if (this._requestsLeft < this._options.latency.measures) {\n\n                    // Measure and save the latency if the headers have been received\n                    if (xhr.readyState == XMLHttpRequest.HEADERS_RECEIVED) {\n                        var labels = this._timingLabels;\n\n                        Timing.mark(labels.end);\n                        var latency = Timing.measure(labels.measure, labels.start, labels.end);\n\n                        if (latency) this._latencies.push(latency);\n\n                        // Abort the current request before we run a new one\n                        this._abort();\n                        this._nextRequest(!latency);\n                    }\n                }\n\n                // Ignore the first request when using the XHR states. See the comments in the start() method for explanations.\n                else {\n                    this._nextRequest();\n                }\n            }\n        },\n        _end: {\n            value: function _end() {\n                var latencies = this._latencies;\n\n                // Get the average latency\n                var avgLatency = latencies.reduce(function (a, b) {\n                    return a + b;\n                }, 0) / (latencies.length || 1);\n                avgLatency = avgLatency || null;\n\n                // If there is not enough measures, display a warning.\n                if (latencies.length < this._options.latency.measures) {\n                    var _options$latency = this._options.latency;\n                    var measures = _options$latency.measures;\n                    var attempts = _options$latency.attempts;\n\n                    console.warn([\"An insufficient number of measures have been processed, this could be due to your web server using\", \"persistant connections or to your client options (measures: \" + measures + \", attempts: \" + attempts + \")\"].join(\" \"));\n                }\n\n                // Trigger the \"end\" event with the average latency and the latency list as parameters\n                this.trigger(\"end\", avgLatency, latencies);\n            }\n        }\n    });\n\n    return LatencyModule;\n})(HttpModule);\n\nmodule.exports = LatencyModule;\n\n},{\"../../utils/helpers\":7,\"../Timing\":6,\"./HttpModule\":4}],6:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar Timing = (function () {\n    function Timing() {\n        _classCallCheck(this, Timing);\n\n        this._marks = {};\n        this._measures = {};\n\n        // Does the browser support the following APIs?\n        this._support = {\n            performance: !!window.performance,\n            userTiming: window.performance && performance.mark,\n            resourceTiming: window.performance && typeof performance.getEntriesByType == \"function\" && performance.timing\n        };\n    }\n\n    _createClass(Timing, {\n        mark: {\n            value: function mark(label) {\n                var support = this._support,\n                    marks = this._marks;\n\n                if (support.userTiming) {\n                    performance.mark(label);\n                } else if (support.performance) {\n                    marks[label] = performance.now();\n                } else {\n                    marks[label] = new Date().getTime();\n                }\n\n                return this;\n            }\n        },\n        measure: {\n            value: function measure(measureLabel, markLabelA, markLabelB) {\n                var support = this._support,\n                    marks = this._marks,\n                    measures = this._measures;\n\n                if (typeof measures[measureLabel] == \"undefined\") {\n                    if (support.userTiming) {\n                        performance.measure(measureLabel, markLabelA, markLabelB);\n                        measures[measureLabel] = performance.getEntriesByName(measureLabel)[0].duration;\n                    } else {\n                        measures[measureLabel] = marks[markLabelB] - marks[markLabelA];\n                    }\n                }\n\n                return measures[measureLabel];\n            }\n        },\n        supportsResourceTiming: {\n            value: function supportsResourceTiming() {\n                return this._support.resourceTiming;\n            }\n        }\n    });\n\n    return Timing;\n})();\n\nmodule.exports = new Timing();\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nexports.isObject = isObject;\nexports.assign = assign;\nexports.defer = defer;\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction isObject(obj) {\n    return obj != undefined && obj != null && typeof obj.valueOf() == \"object\";\n}\n\nfunction assign() {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    var target = arguments[0] === undefined ? {} : arguments[0];\n\n    sources.forEach(function (source) {\n        Object.keys(source).forEach(function (key) {\n            var value = source[key];\n            target[key] = isObject(value) ? assign(target[key], value) : value;\n        });\n    });\n\n    return target;\n}\n\nfunction defer() {\n    var cb = arguments[0] === undefined ? function () {} : arguments[0];\n\n    return new ((function () {\n        var _class = function () {\n            _classCallCheck(this, _class);\n\n            this.cb = cb;\n        };\n\n        _createClass(_class, {\n            run: {\n                value: function run() {\n                    if (this.cb) this.cb();\n                    delete this.cb;\n                }\n            }\n        });\n\n        return _class;\n    })())();\n}\n\n},{}]},{},[1])(1)\n});\n\n\n//# sourceMappingURL=speedtest.js.map","import EventDispatcher from './EventDispatcher';\nimport HttpModule from './Http/HttpModule';\nimport LatencyModule from './Http/LatencyModule';\nimport BandwidthModule from './Http/BandwidthModule';\nimport Timing from './Timing';\nimport {assign} from '../utils/helpers';\n\nexport default class SpeedTest {\n\n    /**\n     * Only for testing purposes! Exposes all the internal classes to the global scope.\n     */\n    static _exposeInternalClasses()\n    {\n        assign(window, {EventDispatcher, HttpModule, LatencyModule, BandwidthModule, Timing});\n    }\n\n    constructor(options = {})\n    {\n        // Initialize the modules\n        this._modules = {};\n        this._setModule('latency', new LatencyModule(options))\n            ._setModule('upload', new BandwidthModule('upload', options))\n            ._setModule('download', new BandwidthModule('download', options));\n    }\n\n    isRequesting()\n    {\n        var modules = this._modules,\n            requesting = false;\n\n        for (var i in modules) {\n            if (modules.hasOwnProperty(i)) {\n                requesting = requesting || modules[i].isRequesting();\n            }\n        }\n\n        return requesting;\n    }\n\n    _setModule(name, object)\n    {\n        if (object) {\n            this[name] = this._modules[name] = object.on('_newRequest', () => !this.isRequesting());\n        }\n\n        return this;\n    }\n\n}\n","export default class EventDispatcher {\n\n    constructor()\n    {\n        // Contains all the event callbacks, organized by event types.\n        this._events = {};\n    }\n\n    on(eventTypes, callback)\n    {\n        eventTypes = Array.isArray(eventTypes) ? eventTypes : [eventTypes];\n\n        eventTypes.forEach(eventType => {\n            var events = this._events[eventType] = this._events[eventType] || [];\n\n            // If the callback isn't already registered, store it.\n            if (!~events.indexOf(callback)) {\n                events.push(callback);\n            }\n        });\n\n        return this;\n    }\n\n    off(eventTypes, callback)\n    {\n        eventTypes = Array.isArray(eventTypes) ? eventTypes : [eventTypes];\n\n        eventTypes.forEach(eventType => {\n            var events = this._events[eventType];\n\n            // If there is no specified callback, simply delete all the callbacks binded to the provided event type.\n            if (callback == undefined && events) {\n                delete this._events[eventType];\n            } else {\n                var eventIndex = events ? events.indexOf(callback) : -1;\n\n                // If the callback is registered, remove it from the array.\n                if (~eventIndex) {\n                    events.splice(eventIndex, 1);\n                }\n            }\n        });\n\n        return this;\n    }\n\n    trigger(eventType, ...extraParameters)\n    {\n        var events = this._events[eventType] || [];\n\n        // A callback can return a boolean value which will be logically compared to the other callbacks values before\n        // being returned by the trigger() method. This allows a callback to send a \"signal\" to the caller, like\n        // cancelling an action.\n        var returnValue = true;\n\n        events.forEach(callback => {\n            // A callback must explicitly return false if it wants the trigger() method to return false, undefined will\n            // not work. This avoids crappy callbacks to mess up with the triggering system.\n            var value = callback(...extraParameters);\n            value = value !== false ? true : false;\n\n            returnValue = returnValue && value; // Compare the result of the callback to the actual return value\n        });\n\n        return returnValue;\n    }\n\n}\n","import HttpModule from './HttpModule';\nimport Timing from '../Timing';\nimport {assign, defer} from '../../utils/helpers';\n\nexport default class BandwidthModule extends HttpModule {\n\n    constructor(loadingType, options = {})\n    {\n        // Instanciate the parent\n        loadingType = (~['upload', 'download'].indexOf(loadingType)) ? loadingType : 'download';\n\n        options = assign({\n            dataSize: {\n                upload: 2 * 1024 * 1024, // 2 MB\n                download: 10 * 1024 * 1024, // 10 MB\n                multiplier: 2\n            }\n        }, options);\n\n        super.constructor(loadingType, options);\n\n        // Define the object properties\n        this._loadingType = loadingType;\n\n        this._intendedEnd = false;\n        this._isRestarting = false;\n\n        this._lastLoadedValue = null;\n        this._speedRecords = [];\n        this._avgSpeed = null;\n\n        this._requestID = 0;\n        this._progressID = 0;\n\n        this._started = false;\n        this._firstProgress = true;\n        this._deferredProgress;\n\n        // Unique labels for each request, exclusively used to make measures.\n        this._timingLabels = {\n            start: null,\n            progress: null,\n            end: null,\n            measure: null\n        };\n\n        // Bind to XHR events\n        this.on('xhr-upload-loadstart', () => Timing.mark(this._timingLabels.start));\n        this.on('xhr-readystatechange', xhr => {\n            if (!this._started && xhr.readyState == XMLHttpRequest.LOADING) {\n                Timing.mark(this._timingLabels.start);\n                this._started = true;\n            }\n        });\n\n        var eventsPrefix = (loadingType == 'upload') ? 'xhr-upload' : 'xhr';\n\n        this.on(`${eventsPrefix}-progress`, (xhr, event) => this._progress(event));\n        this.on(`${eventsPrefix}-timeout`, () => this._timeout());\n        this.on(`${eventsPrefix}-loadend`, () => this._end());\n    }\n\n    start()\n    {\n        var loadingType = this._loadingType,\n            dataSize = this._options.dataSize,\n            reqID = this._requestID++;\n\n        this._intendedEnd = false;\n        this._lastLoadedValue = null;\n        this._speedRecords = [];\n        this._started = false;\n        this._firstProgress = true;\n        this._deferredProgress = defer();\n\n        // Trigger the start event\n        if (!this._isRestarting) {\n            this.trigger('start', (loadingType == 'upload') ? dataSize.upload : dataSize.download);\n        }\n\n        // Create unique timing labels for the new request\n        var labels = this._timingLabels;\n        labels.start = `${loadingType}-${reqID}-start`;\n        labels.progress = `${loadingType}-${reqID}-progress`;\n        labels.end = `${loadingType}-${reqID}-end`;\n        labels.measure = `${loadingType}-${reqID}-measure`;\n\n        // Generate some random data to upload to the server. Here we're using a Blob instead of an ArrayBuffer because\n        // of a bug in Chrome (tested in v33.0.1750.146), causing a freeze of the page while trying to directly upload\n        // an ArrayBuffer (through an ArrayBufferView). The freeze lasts nearly 4.5s for 10MB of data. Using a Blob\n        // seems to solve the problem.\n        var blob = (loadingType == 'upload') ? new Blob([new ArrayBuffer(dataSize.upload)]) : null;\n\n        var type = (loadingType == 'download') ? 'GET' : 'POST';\n\n        // Initiate and send a new request\n        this._newRequest(type, {\n            size: dataSize.download\n        })._sendRequest(blob);\n    }\n\n    abort()\n    {\n        this._intendedEnd = true;\n        return this._abort();\n    }\n\n    _progress(event)\n    {\n        // Ignore the first progress event, it generally contributes to get incoherent values.\n        if (this._firstProgress) return this._firstProgress = false;\n\n        // Execute the previous progress trigger\n        this._deferredProgress.run();\n\n        var labels = this._timingLabels,\n            progressID = this._progressID++,\n            markLabel = `${labels.progress}-${progressID}`,\n            loaded = event.loaded;\n\n        Timing.mark(markLabel);\n\n        // Measure the average speed (B/s) since the request started\n        var avgMeasure = Timing.measure(\n                `${labels.measure}-avg-${progressID}`,\n                labels.start,\n                markLabel\n            ),\n            avgSpeed = loaded / avgMeasure * 1000;\n\n        var instantSpeed;\n\n        if (!this._lastLoadedValue) { // We are executing the first progress event of the current request\n            instantSpeed = avgSpeed; // The instant speed of the first progress event is equal to the average one\n        } else {\n            // Measure the instant speed (B/s), which defines the speed between two progress events.\n            var instantMeasure = Timing.measure(\n                `${labels.measure}-instant-${progressID}`,\n                // Set the mark of the previous progress event as the starting point\n                `${labels.progress}-${progressID - 1}`,\n                markLabel\n            );\n            instantSpeed = (loaded - this._lastLoadedValue) / instantMeasure * 1000;\n        }\n\n        // Save the `loaded` property of the event for the next progress event\n        this._lastLoadedValue = loaded;\n\n        // Defer measures saving and event triggering, this allows to cancel the last progress event, which can generate\n        // incoherent values.\n        this._deferredProgress = defer(() => {\n            this._avgSpeed = avgSpeed;\n            this._speedRecords.push(instantSpeed);\n\n            this.trigger('progress', avgSpeed, instantSpeed);\n        });\n    }\n\n    _timeout()\n    {\n        this._intendedEnd = true;\n    }\n\n    _end()\n    {\n        // A timeout or an abort occured, bypass the further requests and trigger the \"end\" event.\n        if (this._intendedEnd) {\n            this._isRestarting = false;\n            this.trigger('end', this._avgSpeed, this._speedRecords);\n        }\n\n        // The request ended to early, restart it with an increased data size.\n        else {\n            var loadingType = this._loadingType,\n                dataSize = this._options.dataSize;\n\n            dataSize.upload *= dataSize.multiplier;\n            dataSize.download *= dataSize.multiplier;\n\n            this.trigger('restart', (loadingType == 'upload') ? dataSize.upload : dataSize.download);\n\n            this._isRestarting = true;\n            this.start();\n        }\n    }\n\n\n}\n","import EventDispatcher from '../EventDispatcher';\nimport {assign} from '../../utils/helpers';\n\nexport default class HttpModule extends EventDispatcher {\n\n    constructor(moduleName, options = {})\n    {\n        super.constructor();\n\n        options = assign({\n            endpoint: './speedtest.php',\n            delay: 8000\n        }, options);\n\n        // Define the object properties\n        this._options = options;\n        this._moduleName = moduleName;\n        this._xhr = null;\n        this._lastURLToken = null;\n\n        this._requestingOverridden = false;\n        this._requesting = false;\n\n        // Each time a request starts or ends, set the requesting value unless it has been overridden with the\n        // _setRequesting() method.\n        this.on(['xhr-loadstart', 'xhr-upload-loadstart'], () => {\n            if (!this._requestingOverridden) {\n                this._requesting = true;\n            }\n        });\n\n        this.on(['xhr-loadend', 'xhr-upload-loadend'], () => {\n            if (!this._requestingOverridden) {\n                this._requesting = false;\n            }\n        });\n    }\n\n    isRequesting()\n    {\n        return this._requesting;\n    }\n\n    _newRequest(httpMethod, queryParams)\n    {\n        // Check if a callback binded to the \"_newRequest\" event returns false, if it's the case, cancel the request\n        // creation. If the requesting status has been overridden, there's no need to cancel the request since the user\n        // should know what he's doing.\n        if (!this.trigger('_newRequest') && !this._requestingOverridden) {\n            console.warn('To ensure accurate measures, you can only make one request at a time.');\n            return this;\n        }\n\n        var options = this._options,\n            xhr = new XMLHttpRequest(),\n            validHttpMethods = ['GET', 'POST'];\n\n        // Prepare the new request.\n        if (!~validHttpMethods.indexOf(httpMethod)) {\n            console.warn('The HTTP method must be GET or POST.');\n            return this;\n        }\n\n        queryParams = queryParams || {};\n\n        // Generate an URL token to avoid any caching issues. This token will also allow to identify the request in the\n        // Resource Timing entries.\n        var tokenSuffix = (new Date).getTime();\n        this._lastURLToken = `speedtest-${tokenSuffix}`;\n\n        // Append the query parameters\n        var url = options.endpoint;\n        url += ~url.indexOf('?') ? '&' : '?';\n        url += `module=${this._moduleName}`;\n\n        Object.keys(queryParams).forEach(param => {\n            var value = encodeURIComponent(queryParams[param]);\n            url += `&${param}=${value}`;\n        });\n\n        url += `&${this._lastURLToken}`;\n\n        xhr.open(httpMethod, url);\n\n        // Define the timeout of the request\n        xhr.timeout = options.delay;\n\n        // Abort the previous request if it hasn't been sent\n        if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n            this._xhr.abort();\n        }\n\n        // Replace the old request by the new one\n        this._xhr = xhr;\n\n        // Bind all the XHR events\n        var self = this,\n            eventTypes = ['loadstart', 'progress', 'abort', 'error', 'load', 'timeout', 'loadend', 'readystatechange'];\n\n        eventTypes.forEach(eventType => {\n            xhr.addEventListener(eventType, function() {\n                // A last progress event can be triggered once a request has timed out, ignore it.\n                if (eventType == 'progress' && !self._requesting) {\n                    return;\n                }\n\n                self.trigger(`xhr-${eventType}`, xhr, ...arguments);\n            });\n\n            // The XMLHttpRequestUpload interface supports all the above event types except the \"readystatechange\" one\n            if (eventType != 'readystatechange') {\n                xhr.upload.addEventListener(eventType, function() {\n                    self.trigger(`xhr-upload-${eventType}`, xhr, ...arguments);\n                });\n            }\n        });\n\n        return this;\n    }\n\n    _sendRequest(data)\n    {\n        if (this._xhr && this._xhr.readyState == XMLHttpRequest.OPENED) {\n            this._xhr.send(typeof data != 'undefined' ? data : null);\n        } else {\n            console.warn('A request must have been created before it can be sent.');\n        }\n\n        return this;\n    }\n\n    _abort()\n    {\n        if (this._xhr) {\n            this._xhr.abort();\n        }\n\n        return this;\n    }\n\n    _getTimingEntry(callback)\n    {\n        // The Resource Timing entries aren't immediately available once the 'load' event is triggered by an\n        // XMLHttpRequest, we must wait for another process tick to check for a refreshed list.\n        setTimeout((lastURLToken => {\n            return () => {\n                // Filter the timing entries to return only the one concerned by the last request made\n                var entries = performance.getEntriesByType('resource').filter(function(entry) {\n                    return ~entry.name.indexOf(lastURLToken);\n                });\n\n                // Return the entry through the callback\n                typeof callback == 'function' && callback(entries.length ? entries[0] : null);\n            };\n        })(this._lastURLToken), 0);\n\n        return this;\n    }\n\n    _setRequesting(value)\n    {\n        this._requestingOverridden = true;\n        this._requesting = value;\n    }\n\n}\n","import HttpModule from './HttpModule';\nimport Timing from '../Timing';\nimport {assign} from '../../utils/helpers';\n\nexport default class LatencyModule extends HttpModule {\n\n    constructor(options = {})\n    {\n        options = assign({\n            latency: {\n                measures: 5,\n                attempts: 3\n            }\n        }, options, {\n            delay: 0 // We dont want any timeout during a latency calculation\n        });\n\n        super.constructor('latency', options);\n\n        // Define the object properties\n        this._requestsLeft = 0;\n        this._attemptsLeft = 0;\n\n        this._latencies = [];\n        this._requestID = 0;\n\n        // Unique labels for each request, exclusively used to make measures.\n        this._timingLabels = {\n            start: null,\n            end: null,\n            measure: null\n        };\n\n        // Measure the latency with the Resource Timing API once the request is finished\n        if (Timing.supportsResourceTiming()) {\n            this.on('xhr-load', () => this._measure());\n        }\n\n        // If the browser doesn't support the Resource Timing API, we fallback on a Datetime solution.\n        else {\n            // Set a mark when the request starts\n            this.on('xhr-loadstart', () => Timing.mark(this._timingLabels.start));\n\n            // Then make a measure with the previous mark\n            this.on('xhr-readystatechange', xhr => this._measure(xhr));\n        }\n    }\n\n    start()\n    {\n        // Set the number of requests required to establish the network latency. If the browser doesn't support the\n        // Resource Timing API, add a request that will be ignored to avoid a longer request due to a possible\n        // DNS/whatever fetch.\n        let {measures, attempts} = this._options.latency;\n\n        this._requestsLeft = measures;\n        this._attemptsLeft = attempts * measures;\n\n        if (!Timing.supportsResourceTiming()) {\n            this._requestsLeft++;\n            this._attemptsLeft++;\n        }\n\n        // Override the requesting value since a complete latency request consists off multiple ones\n        this._setRequesting(true);\n\n        this._latencies = [];\n        this._nextRequest();\n\n        return this;\n    }\n\n    _nextRequest(retry = false)\n    {\n        const reqID = this._requestID++;\n        let requestsLeft = retry ? this._requestsLeft : this._requestsLeft--;\n\n        if (this._attemptsLeft-- && (requestsLeft || retry)) {\n            // Create unique timing labels for the new request\n            var labels = this._timingLabels;\n            labels.start = `latency-${reqID}-start`;\n            labels.end = `latency-${reqID}-end`;\n            labels.measure = `latency-${reqID}-measure`;\n\n            // Create the new request and send it\n            this._newRequest('GET')._sendRequest();\n        } else {\n            // All the requests are finished, set the requesting status to false.\n            this._setRequesting(false);\n\n            // If all the requests have been executed, calculate the average latency. Since the _getTimingEntry() method\n            // is asynchronous, wait for the next process tick to execute the _end() method, to be sure that all the\n            // latencies have been retrieved.\n            setTimeout(() => this._end(), 0);\n        }\n    }\n\n    _measure(xhr = null)\n    {\n        // With Resource Timing API\n        if (!xhr) {\n            this._getTimingEntry(entry => {\n                // The latency calculation differs between an HTTP and an HTTPS connection\n                // See: http://www.w3.org/TR/resource-timing/#processing-model\n                let latency = !entry.secureConnectionStart\n                        ? entry.connectEnd - entry.connectStart\n                        : entry.secureConnectionStart - entry.connectStart;\n\n                if (latency) this._latencies.push(latency);\n                this._nextRequest(!latency);\n            });\n        }\n\n        // Without Resource Timing API\n        else if (this._requestsLeft < this._options.latency.measures) {\n\n            // Measure and save the latency if the headers have been received\n            if (xhr.readyState == XMLHttpRequest.HEADERS_RECEIVED) {\n                let labels = this._timingLabels;\n\n                Timing.mark(labels.end);\n                let latency = Timing.measure(labels.measure, labels.start, labels.end);\n\n                if (latency) this._latencies.push(latency);\n\n                // Abort the current request before we run a new one\n                this._abort();\n                this._nextRequest(!latency);\n            }\n\n        }\n\n        // Ignore the first request when using the XHR states. See the comments in the start() method for explanations.\n        else {\n            this._nextRequest();\n        }\n    }\n\n    _end()\n    {\n        let latencies = this._latencies;\n\n        // Get the average latency\n        let avgLatency = latencies.reduce((a, b) => a + b, 0) / (latencies.length || 1);\n        avgLatency = avgLatency || null;\n\n        // If there is not enough measures, display a warning.\n        if (latencies.length < this._options.latency.measures) {\n            let {measures, attempts} = this._options.latency;\n\n            console.warn([\n                'An insufficient number of measures have been processed, this could be due to your web server using',\n                `persistant connections or to your client options (measures: ${measures}, attempts: ${attempts})`\n            ].join(' '));\n        }\n\n        // Trigger the \"end\" event with the average latency and the latency list as parameters\n        this.trigger('end', avgLatency, latencies);\n    }\n\n}\n","class Timing {\n\n    constructor()\n    {\n        this._marks = {};\n        this._measures = {};\n\n        // Does the browser support the following APIs?\n        this._support = {\n            performance: !!window.performance,\n            userTiming: window.performance && performance.mark,\n            resourceTiming: window.performance\n                            && (typeof performance.getEntriesByType == \"function\")\n                            && performance.timing\n        };\n    }\n\n    mark(label)\n    {\n        var support = this._support,\n            marks = this._marks;\n\n        if (support.userTiming) {\n            performance.mark(label);\n        } else if (support.performance) {\n            marks[label] = performance.now();\n        } else {\n            marks[label] = (new Date).getTime();\n        }\n\n        return this;\n    }\n\n    measure(measureLabel, markLabelA, markLabelB)\n    {\n        var support = this._support,\n            marks = this._marks,\n            measures = this._measures;\n\n        if (typeof measures[measureLabel] == 'undefined') {\n            if (support.userTiming) {\n                performance.measure(measureLabel, markLabelA, markLabelB);\n                measures[measureLabel] = performance.getEntriesByName(measureLabel)[0].duration;\n            } else {\n                measures[measureLabel] = marks[markLabelB] - marks[markLabelA];\n            }\n        }\n\n        return measures[measureLabel];\n    }\n\n    supportsResourceTiming()\n    {\n        return this._support.resourceTiming;\n    }\n\n}\n\nexport default new Timing();\n","export function isObject(obj)\n{\n    return obj != undefined && obj != null && typeof obj.valueOf() == 'object';\n}\n\nexport function assign(target = {}, ...sources)\n{\n    sources.forEach(source => {\n        Object.keys(source).forEach(key => {\n            let value = source[key];\n            target[key] = isObject(value) ? assign(target[key], value) : value;\n        })\n    });\n\n    return target;\n}\n\nexport function defer(cb = () => {})\n{\n    return new class {\n        constructor()\n        {\n            this.cb = cb;\n        }\n\n        run()\n        {\n            if (this.cb) this.cb();\n            delete this.cb;\n        }\n    };\n}\n"],"sourceRoot":"/source/"}